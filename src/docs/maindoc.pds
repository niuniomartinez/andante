#andante.anId
This function can be used to create a packed 32 bit integer from 8 bit characters.  These can be used for various things, like custom datafile objects or system IDs. Example:
@longcode(#
var
  osTypeLinux: LongWord;
begin
  osTypeLinux := anId ('TUX ')
end;
#)



#andante.anNoError
No error state.
#andante.anNoMemoryError
Can't allocate memory space to perform the operation.
#andante.anNotImplemented
System was not implemented for the current platform.
#andante.anCantInitialize
The system couldn't be initialized or started for some reason.

If you find this error then something is really wrong in your system.  Be sure you have drivers installed and that everything is propery configured.
#andante.anError
Some Andante functions or procedures will assign an error number to this variable.  Note that Andante will not reset this value by itself (except on initialization) so you should reset it (i.e. assign @link(anNoError) to it) before to call a function or procedure that uses this variable.  The routines that use this variable have a reference to @code(anError) in the @bold(See also) section.

All Andante error numbers are negative, so you can use positive values for your custom error states.



#andante.anExitProc
Defines a method used to finalize a subsystem.
@seealso(anAddExitProc)
#andante.anInstall
Initializes the Andante system. No other routines can be called before this (with a few exceptions).
@returns(@true if Andante was successfully initialized, @false if Andante cannot be used.)
@seealso(anUninstall) @seealso(anError)
#andante.anUninstall
Closes the Andante system.

In most cases you don't need to call this, because it's called automatically when the program finalizes.
@seealso(anInstall)
#andante.anAddExitProc
Adds a procedure to the list that need to be called on Andante shutdown.

This is used internally by the different subsystems.  In most cases you don't need to use it.
@returns(@false if it cannot register the procedure.)
@seealso(anRemoveExitProc) @seealso(anError)
#andante.anRemoveExitProc
Removes the procedure from the @italic(exit list).
@seealso(anAddExitProc)



#andante.anDefaultFreq
@seealso(anTimerCounter)
#andante.anTimerCounter
This variable will increment @link(anDefaultFreq) times per second.



#andante.anKeyState
Array of flags indicating the state of each key, ordered by scancode.

Wherever possible these values will be updated asynchronously.

The scancodes are defined as a series of @code(anKey*) constants listed at the @link(Keyboard) section.  For example, you could write:
@longcode(#
  if anKeyState[anKeySpace] then WriteLn ('Space is pressed');
#)
Note that the array is supposed to represent which keys are physically held down and which keys are not, so it is semantically read-only.
@seealso(anInstallKeyboard) @seealso(Keyboard)
#andante.anInstallKeyboard
Installs keyboard handler.

You must call @code(anInstallKeyboard) before using any of the keyboard input routines.  Note that Andante completely takes over the keyboard, so the debugger will not work properly, and under DOS even @code(Ctrl+Alt+Del) will have no effect.
@returns(@False if keyboard wasn't installed properly.)
@seealso(anClearKeyboard)@seealso(anUninstallKeyboard) @seealso(anError)
#andante.anUninstallKeyboard
Restores DOS keyboard handler.

You do not need to call @code(anUninstallKeyboard) because @link(anUninstall) will do this for you.
@seealso(anUninstallKeyboard)
#andante.anClearKeyboard
Clears the keyboard state.
